\section{Nutzersteuerung}
\subsection{Anforderungen}
Um von einem Charaktercontroller sprechen zu können, muss der Agent über Benutzereingaben gesteuert werden. Je nach Spielgenre erfolgt die Steuerung des Charakters unterschiedlich. Für eine intuitive Steuerung wird der Charakter in den meisten Spielen relativ zur Kameraansicht bewegt. Bei First- oder Third-Person-Spielen kann die Kameraansicht zusätzlich über Mausbewegungen gedreht werden. Andere Titel mit einer Top-Down-Ansicht haben hingegen eine feste Kameraansicht. In diesen Spielen wird die Ausrichtung des Charakters daher durch die Mausposition bestimmt. Um den Walker-Agenten zu steuern, muss das Ziel des Läufers zur Laufzeit je nach Benutzereingabe bewegt werden.

In den folgenden Abschnitten wurden beide Ansätze in einem Charaktercontroller-Skript zur Steuerung des Walker-Agents implementiert.

\subsection{First- und Thirdperson-Steuerung}
Die First- oder Third-Person-Steuerung liest zunächst die Tastatureingaben sowie die Mausbewegung auf der Y-Achse ein. Anschließend wird der aktuelle Rotationswinkel basierend auf der Mausbewegung angepasst. Dabei wird die Distanz, die die Maus seit dem letzten Update zurückgelegt hat, nach links als negativer Wert und nach rechts als positiver Wert auf den aktuellen Rotationswinkel addiert. Die Rotation wird durch eine Quaternion bestimmt, die um die vertikale Weltachse gedreht wird. Um die Richtungsvektoren zu berechnen, wird die zuvor berechnete Rotation auf die Basisvektoren angewendet. Zum Schluss werden die Richtungsvektoren mit den Tastatureingaben multipliziert. Mit den Tastatureingaben W und S wird der Input in vertikaler Richtung im Bereich von -1 bis 1 angegeben. Mit den Tastatureingaben A und D wird gleichermaßen die horizontale Richtung angegeben. Abschließend wird das Ziel an die errechnete Position gesetzt, wodurch der Läufer in die angegebene Richtung läuft.

\begin{lstlisting}[caption={ Nutzersteuerung für First- und Thirdperson},captionpos=b,label={lst:nutzersteuerung_3}]
public virtual void FixedUpdate()
    {
        //Einlesen Tastatur Input
        float inputHor = Input.GetAxis("Horizontal");
        float inputVert = Input.GetAxis("Vertical");

        Vector3 position;

        //Einlesen Maus Input
        float mouseX = Input.GetAxis("Mouse X");
        rotAngle += mouseX;

        //Berechnung der Rotation
        rotation = Quaternion.AngleAxis(rotAngle, Vector3.up);

        //Anwendung der Rotation auf Richtungsvektoren
        Vector3 directionForward = rotation * Vector3.forward;
        Vector3 directionRight = rotation * Vector3.right;

        //Position berechnen
        position = root.position + directionForward * inputVert + directionRight * inputHor;

        //Setzen der Zielposition
        target.position = position;
    }
\end{lstlisting}

\subsection{Top-Down-Steuerung}
Das Grundgerüst für die Top-Down-Steuerung ist das gleiche wie bei der First- oder Third-Person-Steuerung. Es unterscheidet sich jedoch darin, dass nicht die Mausbewegung, sondern die Mausposition eingelesen wird. Die Mausposition wird zunächst von einer Pixelkoordinate in eine relative Koordinate im Bereich von 0 bis 1 normiert. Diese Normierung gewährleistet eine konsistente Steuerung unabhängig von der Bildschirmgröße. Anschließend wird die relative Koordinate in einen Bereich von -1 bis 1 konvertiert, um die Position in Relation zum Bildschirmmittelpunkt darzustellen, anstatt zur unteren linken Ecke. Der Vektor, bestehend aus den relativen Koordinaten, gibt die Blickrichtung an. Um die Zielposition zu berechnen, wird die Tastatureingabe mit den Richtungsvektoren der Weltachsen multipliziert. Abschließend wird das Ziel an die berechnete Position gesetzt, wodurch der Läufer in die angegebene Richtung läuft.
\begin{lstlisting}[caption={Nutzersteuerung für Top-Down},captionpos=b,label={lst:nutzersteuerung_2}]
public virtual void FixedUpdate()
    {
        //Einlesen Tastatur Input
        float inputHor = Input.GetAxis("Horizontal");
        float inputVert = Input.GetAxis("Vertical");

        Vector3 position;

        //Einlesen Maus Position
        Vector3 mousePos = Input.mousePosition;

        //Maus Position normalisieren relativ zu Bildschirmauflösung
        float normalizedMouseX = 2 * (mousePos.x / Screen.width) - 1;
        float normalizedMouseY = 2 * (mousePos.y / Screen.height) - 1;
        mousePos = new Vector3(normalizedMouseX, 0, normalizedMouseY);

        //Berechnung der Rotation
        rotation = Quaternion.LookRotation(mousePos, Vector3.up);

        //Position berechnen
        position = root.position + Vector3.forward * inputVert + Vector3.right * inputHor;

        //Setzen der Zielposition
        target.position = position;
    }
\end{lstlisting}
