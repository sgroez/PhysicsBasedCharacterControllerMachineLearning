\section{Nutzersteuerung}
Um von einem Charaktercontroller sprechen zu können muss der Agent über Nutzerinput gesteuert werden können. Mit diesem Gedanke wurde die ersten Anpassungen der Walker Demo implementiert um das Ziel zur Laufzeit über Tastatureingabe zu bewegen.

\subsection{Versuch 1}
\label{subsec:versuch_1}
Das Ziel soll zur Laufzeit durch Tastatureingabe des Nutzers gesteuert werden können.
Um das zu umzusetzen wird die Tastatureingabe eingelesen und darauf basierend das Ziel relativ zur Hüfte des Walkers gesetzt. Über die Richtungsvektoren des lokalen Koordinatensystems der Hüfte wird andhand des Inputs eine Position relativ zur Hüfte berechnet (siehe Listing \ref{lst:nutzersteuerung_1}).
\begin{lstlisting}[caption={Nutzersteuerung erster Prototyp},captionpos=b,label={lst:nutzersteuerung_1}]
void FixedUpdate()
{
    //Einlesen Tastatur Input
    float inputHor = Input.GetAxis("Horizontal");
    float inputVert = Input.GetAxis("Vertical");
        
    //Setzen der Zielposition
    transform.position = root.position + root.forward * inputVert + root.right * inputHor;
}
\end{lstlisting}
Diese Implementierung ermöglicht grundsätzlich, dass der Läufer über die Tastatureingabe gesteuert werden kann, hat aber noch einige Probleme. Das positionieren des Ziels relativ zur Hüfte hat als Konsequenz das jede Bewegung der Hüfte Einfluss auf die Laufrichtung hat, wodurch sich der Läufer nicht stabil steuern lässt. 

\subsection{Versuch 2}
Um die Probleme aus \ref{subsec:versuch_1} zu beheben wird in folgendem Versuch das Ziel relativ zu den Weltachsen gesetzt. In Unity gibt die Vector3 Klasse mit den Feldern forward den Vektor (0,0,1) und mit right den Vektor (1,0,0) in Weltkoordinaten an.
\begin{lstlisting}[caption={Nutzersteuerung berechnung mit Weltachsen},captionpos=b,label={lst:nutzersteuerung_2}]
//Setzen der Zielposition
transform.position = root.position + Vector3.forward * inputVert + Vector3.right * inputHor;
\end{lstlisting}
Durch die Nutzung der Weltachsen anstatt der Hüftrotationsachsen (siehe Listing \ref{lst:nutzersteuerung_2}) kann das Problem behoben werden. Es tritt dadurch jedoch ein weiteres Problem auf. Die Steuerung ist nicht mehr relativ zur Ausrichtung des Läufers und dadurch aus Spielersicht nicht mehr intuitiv, da der Input je nach Rotation des Walkers einen anderen Einfluss hat.

\subsection{Versuch 3}
Die Lösung ist eine Kombination aus den Ideen der ersten beiden Versuche. Die Laufrichtung soll weiterhin relativ zum Läufer bestimmen werden gleichermaßen aber von der wechselhaften Bewegung des Läufers entkoppeln sein.
Das hinzufügen einer separaten Rotationskomponente für die Bestimmung der Blickrichtung erfüllt hier die Kriterien. \\
Zu beginn wird die Blickrichtung mit der Vorwärtskomponente der Hüftrotation gleichgesetzt. Ausgehend von der Startrichtung wird dann über horizontalen Mausinput die Richtung angepasst (siehe Listing \ref{lst:nutzersteuerung_3}).
\begin{lstlisting}[caption={Erweiterung der Nutzersteuerung mit separater Blickrichtung},captionpos=b,label={lst:nutzersteuerung_3}]
void Start()
{
    //Root Position als Startposition festhalten
    startForward = root.forward;
    startRight = root.right;
}
void FixedUpdate()
{
    //Einlesen Tastatur Input
    float inputHor = Input.GetAxis("Horizontal");
    float inputVert = Input.GetAxis("Vertical");

    //Einlesen Maus Input
    float mouseX = Input.GetAxis("Mouse X");
    rotAngle += mouseX;

    //Berechnung der Rotation
    Quaternion rotation = Quaternion.AngleAxis(rotAngle, rotationAxis);

    //Anwendung der Rotation auf Richtungsvektoren
    Vector3 directionForward = rotation * startForward;
    Vector3 directionRight = rotation * startRight;

    //Setzen der Zielposition
    transform.position = root.position + directionForward * inputVert + directionRight * inputHor;
}
\end{lstlisting}
Das Ergebnis ermöglicht die Steuerung des Läufers als Spielecharakter, mit einer gewohnten Steuerung aus schon bestehenden Spieletiteln und ist kompatibel mit einer Drittenperson Ansicht als auch mit der Erstenperson Ansicht.