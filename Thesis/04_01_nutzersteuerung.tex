\section{Nutzersteuerung}
Um von einem Charaktercontroller sprechen zu können muss der Agent über Nutzerinput gesteuert werden können. Mit diesem Gedanke wurde die ersten Anpassungen der Walker Demo implementiert um das Ziel zur Laufzeit über Tastatureingabe zu bewegen.
\begin{lstlisting}[caption={Nutzersteuerung erster Prototyp},captionpos=b,label={lst:nutzersteuerung_1}]
void FixedUpdate()
{
    //Einlesen Tastatur Input
    float inputHor = Input.GetAxis("Horizontal");
    float inputVert = Input.GetAxis("Vertical");
        
    //Setzen der Zielposition
    transform.position = root.position + root.forward * inputVert + root.right * inputHor;
}
\end{lstlisting}
Die Funktion in Listing \ref{lst:nutzersteuerung_1} liest den Input über das Unity InputSystem. Das Ziel wird relativ zur Hüfte gesetzt. Dieser Ansatz funktioniert grundsätzlich, hat aber noch ein grundlegendes Probleme und einige Einschränkungen. Das Problem ist dass die Zielposition in Abhängigkeit der Hüftrotation berechnet wird. Das hat zur folge das Schwankungen des Walkers Einfluss auf die Laufrichtung haben.

\begin{lstlisting}[caption={Nutzersteuerung berechnung mit Weltachsen},captionpos=b,label={lst:nutzersteuerung_2}]
//Setzen der Zielposition
transform.position = root.position + Vector3.forward * inputVert + Vector3.right * inputHor;
\end{lstlisting}
Durch die Nutzung der Weltachsen anstatt der Hüftrotationsachsen (siehe Listing \ref{lst:nutzersteuerung_2}) kann das Problem behoben werden. Es tritt dadurch jedoch ein weiteres Problem auf. Bei Verwendung der Weltachsen ist die Steuerung des Walkers aus Spielersicht nicht mehr intuitiv, da der Input je nach Rotation des Walkers einen anderen Einfluss hat.

Die Lösung für das Problem ist das einführen einer separaten Rotationskomponente für die Blickrichtung. Zu beginn wird die Blickrichtung mit der Vorwärtskomonente der Hüftrotation gleichgesetzt. Ausgehend von der Startrichtung wird dann über horizontalen Mausinput die Richtung angepasst (siehe Listing \ref{lst:nutzersteuerung_3}).

\begin{lstlisting}[caption={Erweiterung der Nutzersteuerung mit separater Blickrichtung},captionpos=b,label={lst:nutzersteuerung_3}]
void Start()
{
    //Root Position als Startposition festhalten
    startForward = root.forward;
    startRight = root.right;
}
void FixedUpdate()
{
    //Einlesen Tastatur Input
    float inputHor = Input.GetAxis("Horizontal");
    float inputVert = Input.GetAxis("Vertical");

    //Einlesen Maus Input
    float mouseX = Input.GetAxis("Mouse X");
    rotAngle += mouseX;

    //Berechnung der Rotation
    Quaternion rotation = Quaternion.AngleAxis(rotAngle, rotationAxis);

    //Anwendung der Rotation auf Richtungsvektoren
    Vector3 directionForward = rotation * startForward;
    Vector3 directionRight = rotation * startRight;

    //Setzen der Zielposition
    transform.position = root.position + directionForward * inputVert + directionRight * inputHor;
}
\end{lstlisting}

Mit dieser Implementierung lässt sich der Walker intuitiv steuern. Das trainierte Modell der Walker Demo beherrscht jedoch nur die Fortbewegung in Blickrichtung. Durch diese Einschränkung lässt sich von der Steuerung mit WASD nur die W Komponente nutzen. Die Vorwärtsbewegung in Kombination mit der Maussteuerung der Blickrichtung ermöglicht es sich nahezu überall hinzubewegen. Eine weitere große Einschränkung ist, das der Walker nicht darauf trainiert ist stehen zu bleiben. Das resultiert darin das der Walker fällt sobald der Nutzer keinen Tastaturinput gibt.