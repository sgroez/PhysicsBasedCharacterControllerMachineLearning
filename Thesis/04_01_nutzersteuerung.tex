\section{Nutzersteuerung}
Um von einem Charaktercontroller sprechen zu können, muss der Agent über Nutzerinput gesteuert werden. Mit dieser Anforderung wurden die ersten Anpassungen der Walker Demo implementiert.

\subsection{Versuch 1}
\label{subsec:versuch_1}
Das Ziel soll zur Laufzeit durch Tastatureingabe des Nutzers gesteuert werden können.
Um das zu umzusetzen wird die Tastatureingabe eingelesen und darauf basierend das Ziel relativ zur Hüfte des Walkers gesetzt. Der Input bestimmt dabei die Distanz zum Läufer auf den Richtungsvektoren des lokalen Koordinatensystems der Hüfte (siehe Listing \ref{lst:nutzersteuerung_1}). Mit den Achsen Vorwärts und Rechts zur Hüfte und dem Input horizontal wie vertikal von -1 bis 1 kann der Läufer in alle vier Richtungen und diagonal bewegt werden.
\begin{lstlisting}[caption={Nutzersteuerung erster Prototyp},captionpos=b,label={lst:nutzersteuerung_1}]
void FixedUpdate()
{
    //Einlesen Tastatur Input
    float inputHor = Input.GetAxis("Horizontal");
    float inputVert = Input.GetAxis("Vertical");
        
    //Setzen der Zielposition
    transform.position = root.position + root.forward * inputVert + root.right * inputHor;
}
\end{lstlisting}
Diese Implementierung ermöglicht, dass der Läufer über die Tastatureingabe gesteuert werden kann, hat aber noch einige Probleme. Das positionieren des Ziels relativ zur Hüfte hat als Konsequenz das jede Bewegung der Hüfte Einfluss auf die Laufrichtung hat, wodurch sich der Läufer nicht stabil steuern lässt. 

\subsection{Versuch 2}
Um das Problem aus \ref{subsec:versuch_1} zu beheben wird in folgendem Versuch das Ziel relativ zu den Weltachsen gesetzt. In Unity gibt die Vector3 Klasse mit den Feldern forward den Vektor (0,0,1) und mit right den Vektor (1,0,0) in Weltkoordinaten an.
\begin{lstlisting}[caption={Nutzersteuerung berechnung mit Weltachsen},captionpos=b,label={lst:nutzersteuerung_2}]
//Setzen der Zielposition
transform.position = root.position + Vector3.forward * inputVert + Vector3.right * inputHor;
\end{lstlisting}
Durch die Nutzung der Weltachsen anstatt der Hüftrotationsachsen (siehe Listing \ref{lst:nutzersteuerung_2}) kann das Problem behoben werden. Die Steuerung ist nicht relativ zur Ausrichtung des Läufers und dadurch am besten für eine Steuerung aus der Top Down Ansicht geeignet.

\subsection{Versuch 3}
Für die Nutzung in First- oder Thirdperson Ansicht soll die Laufrichtung weiterhin relativ zum Läufer bestimmen werden gleichermaßen aber von der wechselhaften Bewegung des Läufers entkoppeln sein.
Das hinzufügen einer separaten Rotationskomponente für die Bestimmung der Blickrichtung erfüllt hier die Kriterien.
Zu beginn wird die Blickrichtung mit der Vorwärtskomponente der Hüftrotation gleichgesetzt. Ausgehend von der Startrichtung wird dann über horizontalen Mausinput die Richtung angepasst (siehe Listing \ref{lst:nutzersteuerung_3}).
\begin{lstlisting}[caption={Erweiterung der Nutzersteuerung mit separater Blickrichtung},captionpos=b,label={lst:nutzersteuerung_3}]
void Start()
{
    //Root Position als Startposition festhalten
    startForward = root.forward;
    startRight = root.right;
}
void FixedUpdate()
{
    //Einlesen Tastatur Input
    float inputHor = Input.GetAxis("Horizontal");
    float inputVert = Input.GetAxis("Vertical");

    //Einlesen Maus Input
    float mouseX = Input.GetAxis("Mouse X");
    rotAngle += mouseX;

    //Berechnung der Rotation
    Quaternion rotation = Quaternion.AngleAxis(rotAngle, rotationAxis);

    //Anwendung der Rotation auf Richtungsvektoren
    Vector3 directionForward = rotation * startForward;
    Vector3 directionRight = rotation * startRight;

    //Setzen der Zielposition
    transform.position = root.position + directionForward * inputVert + directionRight * inputHor;
}
\end{lstlisting}
Das Ergebnis ermöglicht die Steuerung des Läufers als Spielcharakter, mit einer gewohnten Steuerung aus schon bestehenden Spieltiteln und ist kompatibel mit einer dritte Person Ansicht als auch mit der erste Person Ansicht.